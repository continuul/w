#!/usr/bin/env bash

set -e

VERSION="1.1.0"
QUIET=true

log() {
  printf "  \033[36m%10s\033[0m : \e[2m%s\e[22m\033[0m\n" $1 $2
}

abort() {
  printf "\n  \033[31mError: $@\033[0m\n\n" && exit 1
}

enter_fullscreen() {
  tput smcup
  stty -echo
}

leave_fullscreen() {
  tput rmcup
  stty echo
}

handle_sigint() {
  leave_fullscreen
  S="$?"
  kill 0
  exit $S
}

handle_sigtstp() {
  leave_fullscreen
  kill -s SIGSTOP $$
}

set_quiet() {
  QUIET=true
}

erase_line() {
  printf "\033[1A\033[2K"
}

__ws_home ()
{
    ws_path=`dirname $0`
    ws_home=`dirname ${ws_path}`
    echo "$ws_home"
}

__ws_attr ()
{
	if [ -z "${1-}" ]; then
		if [ -n "${__ws_attr-}" ]; then
			echo "$__ws_attr"
		elif [ -f .wsattr ]; then
			echo .wsattr
		else
		    __ws_attr "$(dirname `pwd`)"
		fi
	elif [ -f "$1/.wsattr" ]; then
		echo "$1/.wsattr"
	elif [ "$1" != "/" ]; then
		__ws_attr "$(dirname $1)"
	else
        echo "$(ws --home)/.wsattr"
	fi
}

__ws_dir ()
{
  . $(__ws_attr)
  echo ${WORKSPACES_DIR:=$HOME/workspaces}
}

__cur_dir ()
{
  echo $(__ws_dir)/$workspace
}

activate() {
  test -z $1 && abort "workspace required"
  local workspace=$1
  check_current_workspace
  if test "$workspace" != "$active"; then
    local dir=$(__ws_dir)/$workspace
    cd $dir/src
    bash --init-file $dir/bin/activate
  fi
}

check_current_workspace() {
  if [ ! -z "$WS_WORKSPACE"  ]; then
    active=$WS_WORKSPACE
  fi
}

remove_workspace() {
  test -z $1 && abort "workspace(s) required"
  check_current_workspace
  while test $# -ne 0; do
    local workspace=${1#v}
    [ "$workspace" == "$active" ] && abort "cannot remove currently active workspace ($active)"
    rm -rf $(__ws_dir)/$workspace
    shift
  done
}

create_workspace() {
  . $(__ws_home)/.wsattr
  local workspace=${1#v}
  local dir=$(__ws_dir)/$workspace

  # if the workspace already exists, activate it and exit
  if test -d $dir; then
    if [[ ! -e $dir/w.lock ]] ; then
      if $ACTIVATE ; then
        activate $workspace
      fi
      exit
    fi
  fi

  # install a new workspace
  log install $(__ws_dir)/$workspace

  log mkdir $dir
  mkdir -p $dir
  mkdir -p $dir/bin
  mkdir -p $dir/src
  if [ $? -ne 0 ] ; then
    abort "sudo required"
  else
    touch $dir/w.lock
  fi

  # add template expansion, template support here...

  cat << EOF > $dir/bin/activate
export WS_ENV=$(realpath $dir)
export WS_WORKSPACE=$workspace
export WORKSPACE=$(realpath $dir/src)
export TZ=UTC
export PATH="$PATH:$(realpath $dir)/bin"
EOF

  (
    . $dir/bin/activate

    for once in $(__ws_home)/etc/*.once; do
      log once $once
      . $once
    done

    for activation in $(__ws_home)/etc/*.activation; do
      log activation $activation
      cat << EOF >> $dir/bin/activate
  # Template-Start: $(basename $activation .activation)
  EOF
      cat $activation >> $dir/bin/activate
      cat << EOF >> $dir/bin/activate
  # Template-End: $(basename $activation .activation)
  EOF
    done
  )

  [ $QUIET == false ] && erase_line
  rm -f $dir/w.lock

  if $ACTIVATE ; then
    log installed $workspace
    activate $workspace
  fi
  echo
}

workspaces_paths() {
  find $(__ws_dir) -mindepth 1 -maxdepth 1 -type d \
    | sed 's|'$(__ws_dir)'/||g' \
    | sort
}

list_workspaces_installed() {
  echo $(workspaces_paths)
  for workspaces in $(workspaces_paths); do
    echo $workspace
  done
}

display_workspaces_with_selected() {
  selected=$1
  echo
  for workspace in $(workspaces_paths); do
    if test "$workspace" = "$selected"; then
      printf "  \033[36mο\033[0m $workspace\033[0m\n"
    else
      printf "    \e[2m$workspace\e[22m\n"
    fi
  done
  echo
}

next_workspace_installed() {
  list_workspaces_installed | grep $selected -A 1 | tail -n 1
}

prev_workspace_installed() {
  list_workspaces_installed | grep $selected -B 1 | head -n 1
}

display_dir() {
  echo "$(__ws_dir)"
}

display_workspaces() {
  enter_fullscreen
  check_current_workspace
  clear

  display_workspaces_with_selected $active

  trap handle_sigint INT
  trap handle_sigtstp SIGTSTP

  ESCAPE_SEQ=$'\033'
  UP=$'A'
  DOWN=$'B'

  while true; do
    read -rsn 1 key
    case "$key" in
      $ESCAPE_SEQ)
        # Handle ESC sequences followed by other characters, i.e. arrow keys
        read -rsn 1 -t 1 tmp
        if  [[ "$tmp" == "[" ]]; then
          read -rsn 1 -t 1 arrow
          case "$arrow" in
            $UP)
              clear
              display_workspaces_with_selected $(prev_workspace_installed)
              ;;
            $DOWN)
              clear
              display_workspaces_with_selected $(next_workspace_installed)
              ;;
          esac
        fi
        ;;
      "k")
        clear
        display_workspaces_with_selected $(prev_workspace_installed)
        ;;
      "j")
        clear
        display_workspaces_with_selected $(next_workspace_installed)
        ;;
      "q")
        clear
        leave_fullscreen
        exit
        ;;
      "")
        # enter key returns empty string
        activate $selected
        leave_fullscreen
        echo $selected
        exit
        ;;
    esac
  done
}

display_remote_workspaces() {
  check_current_workspace
  echo
  for workspace in $(workspaces_paths); do
    if test "$workspace" = "$active"; then
      printf "  \033[36mο\033[0m $workspace\033[0m\n"
    else
      printf "    \e[2m$workspace\e[22m\n"
    fi
  done
  echo
}

display_wS_version() {
  echo $VERSION && exit 0
}

display_help() {
  cat <<-EOF
  Usage: ws [options/env] [COMMAND] [args]
  Environments:
    ws [COMMAND] [args]        Uses default env (node)
  Commands:
    ws                         Output workspaces created
    ws <id>                    Creates a workspace named <id>
    ws use <id> [args ...]     Execute workspace <id> with [args ...]
    ws rm <id ...>             Remove the given workspace(s)
    ws prune                   Remove all workspaces except the current workspace
  Options:
    -V, --version   Output current version of w
    -H, --home      Display home directory
    -h, --help      Display help information
    -d, --dir       Display the workspaces directory
    -q, --quiet     Disable verbose output (if available)
  Aliases:
    which   bin
    use     as
    list    ls
    -       rm
EOF
}

if test $# -eq 0; then
  display_help
  exit
else
  while test $# -ne 0; do
    case $1 in
      -n|--nonactivation) ACTIVATE=false ;;
      -V|--version) display_wS_version ;;
      -d|--dir) display_dir; exit ;;
      -h|--help|help) display_help; exit ;;
      -H|--home|home) __ws_home; exit ;;
      -q|--quiet) set_quiet ;;
      project) DEFAULT=2 ;;
      bin|which) display_bin_path_for_version $2; exit ;;
      as|use) shift; activate $@; exit ;;
      rm|-) shift; remove_workspace $@; exit ;;
      prune) prune_versions; exit ;;
      ls|list) display_remote_workspaces; exit ;;
      *) create_workspace $1; exit ;;
    esac
    shift
  done
fi
